# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Maciej Olko <maciej.olko@gmail.com>, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-24 14:14+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Maciej Olko <maciej.olko@gmail.com>, 2021\n"
"Language-Team: Polish (https://www.transifex.com/python-doc/teams/5390/pl/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pl\n"
"Plural-Forms: nplurals=4; plural=(n==1 ? 0 : (n%10>=2 && n%10<=4) && "
"(n%100<12 || n%100>14) ? 1 : n!=1 && (n%10>=0 && n%10<=1) || (n%10>=5 && "
"n%10<=9) || (n%100>=12 && n%100<=14) ? 2 : 3);\n"

msgid ":mod:`asyncore` --- Asynchronous socket handler"
msgstr "Moduł :mod:`asyncore` --- Asynchroniczna obsługa gniazda"

msgid "**Source code:** :source:`Lib/asyncore.py`"
msgstr ""

msgid ""
"The :mod:`asyncore` module is deprecated (see :pep:`PEP 594 <594#asyncore>` "
"for details). Please use :mod:`asyncio` instead."
msgstr ""

msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr ""

msgid ""
"This module provides the basic infrastructure for writing asynchronous  "
"socket service clients and servers."
msgstr ""
"Ten moduł dostarcza podstawową infrastrukturę do pisania asynchronicznych "
"klientów i serwerów usługi gniazd."

msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ""

msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""

msgid ""
"There are only two ways to have a program on a single processor do  \"more "
"than one thing at a time.\" Multi-threaded programming is the  simplest and "
"most popular way to do it, but there is another very different technique, "
"that lets you have nearly all the advantages of  multi-threading, without "
"actually using multiple threads.  It's really  only practical if your "
"program is largely I/O bound.  If your program is processor bound, then pre-"
"emptive scheduled threads are probably what you really need.  Network "
"servers are rarely processor bound, however."
msgstr ""
"Istnieją tylko dwa sposoby aby program na pojedynczym procesorze robił "
"\"więcej niż jedną rzecz na raz.\" Wielo-wątkowe programowanie jest "
"najprostszą i najczęściej spotykaną drogą aby to robić, ale istnieje inna "
"bardzo odmienna technika, która pozwala mieć prawie wszystkie zalety "
"wielowątkowości, bez używania wielu wątków. Jest ona tylko pomocna jeśli "
"twój program jest w większości związany z wejściem/wyjściem. Jeśli twój "
"program jest związany z procesorem, wtedy wywłaszczające planowane wątki są "
"najczęściej tym czego potrzebujesz. Serwery sieciowe jednakże są rzadko "
"związane z procesorem."

msgid ""
"If your operating system supports the :c:func:`select` system call in its I/"
"O library (and nearly all do), then you can use it to juggle multiple "
"communication channels at once; doing other work while your I/O is taking "
"place in the \"background.\"  Although this strategy can seem strange and "
"complex, especially at first, it is in many ways easier to understand and "
"control than multi-threaded programming.  The :mod:`asyncore` module solves "
"many of the difficult problems for you, making the task of building "
"sophisticated high-performance network servers and clients a snap.  For "
"\"conversational\" applications and protocols the companion :mod:`asynchat` "
"module is invaluable."
msgstr ""

msgid ""
"The basic idea behind both modules is to create one or more network "
"*channels*, instances of class :class:`asyncore.dispatcher` and :class:"
"`asynchat.async_chat`.  Creating the channels adds them to a global map, "
"used by the :func:`loop` function if you do not provide it with your own "
"*map*."
msgstr ""
"Podstawowym pomysłem stojącym za oboma modułami jest stworzenie jednego lub "
"więcej *kanałów*, przykładów uogólnienia :class:`asyncore.dispatcher` i :"
"class:`asynchat.async_chat`. Utworzenie kanałów dodaje je do globalnej mapy, "
"używanej przez funkcję :func:`loop` jeśli dostarczysz jej swojej własnej "
"*mapy*."

msgid ""
"Once the initial channel(s) is(are) created, calling the :func:`loop` "
"function activates channel service, which continues until the last channel "
"(including any that have been added to the map during asynchronous service) "
"is closed."
msgstr ""
"Gdy początkowy(e) kanał(y) jest(są) tworzony(e), wywołanie funkcji :func:"
"`loop` aktywuje usługę kanału, która kontynuuje zanim ostatni kanał "
"(włączając w to jakiekolwiek które zostały dodane do mapy podczas "
"asynchronicznej usługi) nie zostanie zamknięty."

msgid ""
"Enter a polling loop that terminates after count passes or all open channels "
"have been closed.  All arguments are optional.  The *count* parameter "
"defaults to ``None``, resulting in the loop terminating only when all "
"channels have been closed.  The *timeout* argument sets the timeout "
"parameter for the appropriate :func:`~select.select` or :func:`~select.poll` "
"call, measured in seconds; the default is 30 seconds.  The *use_poll* "
"parameter, if true, indicates that :func:`~select.poll` should be used in "
"preference to :func:`~select.select` (the default is ``False``)."
msgstr ""

msgid ""
"The *map* parameter is a dictionary whose items are the channels to watch. "
"As channels are closed they are deleted from their map.  If *map* is "
"omitted, a global map is used. Channels (instances of :class:`asyncore."
"dispatcher`, :class:`asynchat.async_chat` and subclasses thereof) can freely "
"be mixed in the map."
msgstr ""
"Parametr *map* jest słownikiem którego elementami są kanały do oglądania. "
"Gdy kanały są zamykane są one kasowane z ich mapy. Jeśli *mapa* jest "
"pominięta, nadrzędna mapa jest używana. Kanały (przykłady uogólnienia :class:"
"`asyncore.dispatcher` i :class:`asynchat.async_chat` i podrzędne uogólnienia "
"tychże) mogą dowolnie być mieszane wewnątrz mapy."

msgid ""
"The :class:`dispatcher` class is a thin wrapper around a low-level socket "
"object. To make it more useful, it has a few methods for event-handling "
"which are called from the asynchronous loop.   Otherwise, it can be treated "
"as a normal non-blocking socket object."
msgstr ""
"Uogólnienie :class:`dispatcher` jest cienkim opakowaniem wokół "
"niskopoziomowego przedmiotu gniazda. Aby uczynić je bardziej użytecznym, ma "
"kilka sposobów postępowania dla obsługi-zdarzeń które są wzywane z "
"asynchronicznej pętli. Poza tym, może być traktowana jako zwyczajny "
"nieblokujący przedmiot gniazda."

msgid ""
"The firing of low-level events at certain times or in certain connection "
"states tells the asynchronous loop that certain higher-level events have "
"taken place.  For example, if we have asked for a socket to connect to "
"another host, we know that the connection has been made when the socket "
"becomes writable for the first time (at this point you know that you may "
"write to it with the expectation of success).  The implied higher-level "
"events are:"
msgstr ""
"Odpalanie niskopoziomowych zdarzeń w konkretnych momentach lub w konkretnych "
"stanach połączeń mówi pętli asynchronicznej że konkretne wyższego poziomu "
"zdarzenia miały miejsce. Dla przykładu, jeśli żądaliśmy aby gniazdo "
"podłączone było do innego hosta, wiemy że połączenie zostało ustanowione gdy "
"gniazdo stanie się możliwe do zapisania po raz pierwszy (w tym momencie "
"wiesz że możesz zapisać do niego oczekując powodzenia). Dorozumiane "
"zdarzenia wyższego poziomu to:"

msgid "Event"
msgstr "Zdarzenie"

msgid "Description"
msgstr "Opis"

msgid "``handle_connect()``"
msgstr "``handle_connect()``"

msgid "Implied by the first read or write event"
msgstr "Domyślne przez pierwsze zdarzenie odczytu lub zapisu"

msgid "``handle_close()``"
msgstr "``handle_close()``"

msgid "Implied by a read event with no data available"
msgstr "Domyślne przy zdarzeniu odczytu bez dostępnych danych"

msgid "``handle_accepted()``"
msgstr ""

msgid "Implied by a read event on a listening socket"
msgstr "Domyślne przy zdarzeniu czytania na nasłuchującym gnieździe"

msgid ""
"During asynchronous processing, each mapped channel's :meth:`readable` and :"
"meth:`writable` methods are used to determine whether the channel's socket "
"should be added to the list of channels :c:func:`select`\\ ed or :c:func:"
"`poll`\\ ed for read and write events."
msgstr ""

msgid ""
"Thus, the set of channel events is larger than the basic socket events.  The "
"full set of methods that can be overridden in your subclass follows:"
msgstr ""
"Dlatego, zestaw zdarzeń kanałów jest większy, niż podstawowych zdarzeń "
"gniazda. Pełny zestaw sposobów postępowania, które mogą być przesłonięte w "
"twoim podrzędnym uogólnieniu jest następujący:"

msgid ""
"Called when the asynchronous loop detects that a :meth:`read` call on the "
"channel's socket will succeed."
msgstr ""
"Wywoływane, gdy asynchroniczna pętla wykryje, że wywołanie :meth:`read` na "
"gnieździe kanału odniesie sukces."

msgid ""
"Called when the asynchronous loop detects that a writable socket can be "
"written.  Often this method will implement the necessary buffering for "
"performance.  For example::"
msgstr ""
"Wywoływane, gdy asynchroniczna pętla wykryje, że możliwe do zapisu gniazdo "
"może być zapisane. Często ten sposób postępowania będzie wypełniał konieczne "
"wczytywanie z wyprzedzeniem dla poprawy wydajności. Dla przykładu::"

msgid ""
"Called when there is out of band (OOB) data for a socket connection.  This "
"will almost never happen, as OOB is tenuously supported and rarely used."
msgstr ""
"Wywoływane gdy są dane poza zakresem (OOB) dla połączenia z gniazdem. To "
"raczej nie wystąpi nigdy, jako że OOB jest rzadko wspierany i rzadziej "
"jeszcze używany."

msgid ""
"Called when the active opener's socket actually makes a connection.  Might "
"send a \"welcome\" banner, or initiate a protocol negotiation with the "
"remote endpoint, for example."
msgstr ""
"Wywoływane gdy gniazdo aktywnego otwierającego właściwie wywoła połączenie. "
"Może wysłać \"powitalny\" banner, lub zainicjować negocjację protokołu z "
"zewnętrznym punktem końcowym, dla przykładu."

msgid "Called when the socket is closed."
msgstr "Wywoływany gdy gniazdo jest zamykane."

msgid ""
"Called when an exception is raised and not otherwise handled.  The default "
"version prints a condensed traceback."
msgstr ""
"Wywoływane gdy wyjątek jest zgłaszany i nie jest inaczej obsługiwany. "
"Domyślna wersja wypisuje skumulowany wypis."

msgid ""
"Called on listening channels (passive openers) when a connection can be "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint. Deprecated in version 3.2; use :meth:"
"`handle_accepted` instead."
msgstr ""

msgid ""
"Called on listening channels (passive openers) when a connection has been "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint.  *sock* is a *new* socket object usable to send "
"and receive data on the connection, and *addr* is the address bound to the "
"socket on the other end of the connection."
msgstr ""

msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which read events can "
"occur.  The default method simply returns ``True``, indicating that by "
"default, all channels will be interested in read events."
msgstr ""
"Wywoływane za każdym razem dla asynchronicznej pętli aby ustalić, czy "
"gniazdo kanału powinno być dodane do listy na której zdarzenia wczytywania "
"mogą następować. Domyślny sposób po prostu zwraca ``Prawdę`` - z ang. - "
"``True``, wskazując że domyślnie wszystkie kanały będą zainteresowane "
"zdarzeniami wczytywania."

msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which write events can "
"occur.  The default method simply returns ``True``, indicating that by "
"default, all channels will be interested in write events."
msgstr ""
"Wywoływane za każdym razem dla asynchronicznej pętli aby ustalić, czy "
"gniazdo kanału powinno być dodawane do listy na której zdarzenia zapisu mogą "
"następować. Domyślny sposób postępowania po prostu zwraca ``Prawdę`` - z "
"ang. - ``True``, wskazując że domyślnie, wszystkie kanały będą "
"zainteresowane zdarzeniami zapisu."

msgid ""
"In addition, each channel delegates or extends many of the socket methods. "
"Most of these are nearly identical to their socket partners."
msgstr ""
"Na dodatek, każdy kanał deleguje lub rozszerza wiele ze sposobów "
"postępowania gniazd. Większość z tych jest prawie identyczna z ich "
"partnerami gniazda."

msgid ""
"This is identical to the creation of a normal socket, and will use the same "
"options for creation.  Refer to the :mod:`socket` documentation for "
"information on creating sockets."
msgstr ""
"To jest identyczne z utworzeniem normalnego gniazda, i będzie używało tych "
"samych opcji dla tworzenia. Zajrzyj do dokumentacji do :mod:`socket` po "
"więcej informacji o tworzeniu gniazd."

msgid "*family* and *type* arguments can be omitted."
msgstr ""

msgid ""
"As with the normal socket object, *address* is a tuple with the first "
"element the host to connect to, and the second the port number."
msgstr ""
"Tak jak z normalnymi przedmiotami gniazd, *adres* - z ang. - *address* jest "
"krotką z pierwszym elementem hosta do którego się podłącza, i drugim numerem "
"portu."

msgid "Send *data* to the remote end-point of the socket."
msgstr ""
"Prześlij *dane* - z ang. - *data* do odległego punktu końcowego gniazda."

msgid ""
"Read at most *buffer_size* bytes from the socket's remote end-point.  An "
"empty bytes object implies that the channel has been closed from the other "
"end."
msgstr ""

msgid ""
"Note that :meth:`recv` may raise :exc:`BlockingIOError` , even though :func:"
"`select.select` or :func:`select.poll` has reported the socket ready for "
"reading."
msgstr ""

msgid ""
"Listen for connections made to the socket.  The *backlog* argument specifies "
"the maximum number of queued connections and should be at least 1; the "
"maximum value is system-dependent (usually 5)."
msgstr ""
"Nasłuchuj połączeń wykonywanych do gniazda. Parametr *wstecznego logu* - z "
"ang. - *backlog* określa maksymalną liczbę kolejkowanych połączeń i powinien "
"być równy przynajmniej 1; Wartość maksymalna jest zależna od systemu (zwykle "
"jest równa 5)."

msgid ""
"Bind the socket to *address*.  The socket must not already be bound.  (The "
"format of *address* depends on the address family --- refer to the :mod:"
"`socket` documentation for more information.)  To mark the socket as re-"
"usable (setting the :const:`SO_REUSEADDR` option), call the :class:"
"`dispatcher` object's :meth:`set_reuse_addr` method."
msgstr ""
"Połącz gniazdo z *adresem*. Gniazdo nie może być już połączone z adresem. "
"(Format *adresu* zależy od rodziny adresów --- zajrzyj do dokumentacji :mod:"
"`socket` po więcej informacji.) Aby oznaczyć gniazdo jako możliwe do "
"ponownego użycia - z ang. - re-usable (ustawiając opcję :const:"
"`SO_REUSEADDR`), wywołaj sposób postępowania :meth:`set_reuse_addr` obiektu :"
"class:`dispatcher`."

msgid ""
"Accept a connection.  The socket must be bound to an address and listening "
"for connections.  The return value can be either ``None`` or a pair ``(conn, "
"address)`` where *conn* is a *new* socket object usable to send and receive "
"data on the connection, and *address* is the address bound to the socket on "
"the other end of the connection. When ``None`` is returned it means the "
"connection didn't take place, in which case the server should just ignore "
"this event and keep listening for further incoming connections."
msgstr ""

msgid ""
"Close the socket.  All future operations on the socket object will fail. The "
"remote end-point will receive no more data (after queued data is flushed).  "
"Sockets are automatically closed when they are garbage-collected."
msgstr ""
"Zamknij gniazdo. Wszystkie przyszłe operacje na gnieździe zawiodą. Odległy "
"koniec nie dostanie więcej danych (po tym jak zakolejkowane dane zostaną "
"przesłane). Gniazda są automatycznie zamykane gdy są poddawane zbieraniu "
"śmieci."

msgid ""
"A :class:`dispatcher` subclass which adds simple buffered output capability, "
"useful for simple clients. For more sophisticated usage use :class:`asynchat."
"async_chat`."
msgstr ""

msgid ""
"A file_dispatcher takes a file descriptor or :term:`file object` along with "
"an optional map argument and wraps it for use with the :c:func:`poll` or :c:"
"func:`loop` functions.  If provided a file object or anything with a :c:func:"
"`fileno` method, that method will be called and passed to the :class:"
"`file_wrapper` constructor."
msgstr ""

msgid ":ref:`Availability <availability>`: Unix."
msgstr ""

msgid ""
"A file_wrapper takes an integer file descriptor and calls :func:`os.dup` to "
"duplicate the handle so that the original handle may be closed independently "
"of the file_wrapper.  This class implements sufficient methods to emulate a "
"socket for use by the :class:`file_dispatcher` class."
msgstr ""

msgid "asyncore Example basic HTTP client"
msgstr "Podstawowy klient HTTP Przykładu asyncore"

msgid ""
"Here is a very basic HTTP client that uses the :class:`dispatcher` class to "
"implement its socket handling::"
msgstr ""
"Tu jest bardzo podstawowy klient HTTP który używa uogólnienia :class:"
"`dispatcher` do wypełnienia jego obsługi gniazda::"

msgid "asyncore Example basic echo server"
msgstr ""

msgid ""
"Here is a basic echo server that uses the :class:`dispatcher` class to "
"accept connections and dispatches the incoming connections to a handler::"
msgstr ""
