# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Maciej Olko <maciej.olko@gmail.com>, 2022
# Ciarbin <mrciarbin@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-07 14:12+0000\n"
"PO-Revision-Date: 2021-06-28 01:50+0000\n"
"Last-Translator: Ciarbin <mrciarbin@gmail.com>, 2022\n"
"Language-Team: Polish (https://app.transifex.com/python-doc/teams/5390/pl/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pl\n"
"Plural-Forms: nplurals=4; plural=(n==1 ? 0 : (n%10>=2 && n%10<=4) && "
"(n%100<12 || n%100>14) ? 1 : n!=1 && (n%10>=0 && n%10<=1) || (n%10>=5 && "
"n%10<=9) || (n%100>=12 && n%100<=14) ? 2 : 3);\n"

msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "Arytmetyka liczb zmiennoprzecinkowych: Problemy i ograniczenia"

msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the **decimal** fraction ``0.125`` has "
"value 1/10 + 2/100 + 5/1000, and in the same way the **binary** fraction "
"``0.001`` has value 0/2 + 0/4 + 1/8. These two fractions have identical "
"values, the only real difference being that the first is written in base 10 "
"fractional notation, and the second in base 2."
msgstr ""
"Liczby zmiennoprzecinkowe są reprezentowane w komputerze jako ułamki o "
"podstawie 2 (binarne). Na przykład **dziesiętny** ułamek ``0.125`` ma "
"wartość 1/10 + 2/100 + 5/1000 i analogicznie **binarny** ułamek ``0.001`` ma "
"wartość 0/2 + 0/4 + 1/8. Te dwa ułamki mają identyczne wartości, a jedyną "
"prawdziwą różnicą jest to, że pierwszy jest zapisany w notacji ułamkowej o "
"podstawie 10, a drugi o podstawie 2."

msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"Niestety, większości ułamków dziesiętnych nie można przedstawić dokładnie "
"jako ułamków binarnych. Konsekwencją jest to, że ogólnie wprowadzane "
"dziesiętne liczby zmiennoprzecinkowe są jedynie przybliżane przez binarne "
"liczby zmiennoprzecinkowe faktycznie przechowywane w maszynie."

msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"Problem jest łatwiejszy do zrozumienia na początku przy podstawie 10. Rozważ "
"ułamek 1/3. Możesz go przybliżyć jako ułamek o podstawie 10::"

msgid "or, better, ::"
msgstr "albo lepiej::"

msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"i tak dalej. Bez względu na to, ile cyfr jesteś w stanie zapisać, wynik "
"nigdy nie będzie dokładnie 1/3, ale będzie coraz lepszym przybliżeniem 1/3."

msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"W ten sam sposób, bez względu na to, ile cyfr o podstawie 2 chcesz użyć, "
"wartość dziesiętna 0,1 nie może być dokładnie przedstawiona jako ułamek o "
"podstawie 2. W podstawie 2, 1/10 to ułamek okresowy ::"

msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and "
"with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly "
"equal to the true value of 1/10."
msgstr ""
"Zatrzymaj się na dowolnej skończonej liczbie bitów, a otrzymasz "
"przybliżenie. Na większości dzisiejszych maszyn liczby zmiennoprzecinkowe są "
"aproksymowane przy użyciu ułamka binarnego z licznikiem wykorzystującym "
"pierwsze 53 bity, zaczynając od najbardziej znaczącego bitu i mianownikiem "
"jako potęgą dwójki. W przypadku 1/10 ułamek binarny jest równy "
"``3602879701896397 / 2 ** 55`` i jest zbliżony do prawdziwej wartości 1/10, "
"ale nie do końca jej równy."

msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display ::"
msgstr ""
"Wielu użytkowników nie jest świadomych przybliżenia ze względu na sposób "
"wyświetlania wartości. Python wypisuje tylko przybliżenie dziesiętne do "
"prawdziwej wartości dziesiętnej przybliżenia binarnego zapisanego przez "
"maszynę. Na większości maszyn, gdyby Python miał wydrukować prawdziwą "
"wartość dziesiętną przybliżenia binarnego zapisanego dla 0,1 musiałby "
"wyświetlić ::"

msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead ::"
msgstr ""
"To więcej cyfr, niż większość ludzi uważa za przydatne, więc Python "
"utrzymuje liczbę cyfr tak by były one do opanowania, wyświetlając zamiast "
"tego zaokrągloną wartość ::"

msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"Pamiętaj tylko, że chociaż wydrukowany wynik wygląda jak dokładna wartość "
"1/10, rzeczywista zapisana wartość to najbliższa reprezentatywna część "
"binarna."

msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"Co ciekawe, istnieje wiele różnych liczb dziesiętnych, które mają ten sam "
"najbliższy przybliżony ułamek binarny. Na przykład liczby ``0.1``, "
"``0.10000000000000001`` i "
"``0.1000000000000000055511151231257827021181583404541015625`` są wszystkie "
"przybliżone przez ``3602879701896397 / 2 ** 55``. Ponieważ wszystkie te "
"wartości dziesiętne mają to samo przybliżenie, każda z nich może zostać "
"wyświetlona przy jednoczesnym zachowaniu niezmiennika ``eval(repr(x)) == x``."

msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the "
"shortest of these and simply display ``0.1``."
msgstr ""
"W przeszłości, interaktywny prompt oraz wbudowana funkcja Pythona :func:"
"`repr` wybierały tę z 17 cyframi znaczącymi, ``0.10000000000000001``. "
"Począwszy od Pythona 3.1, Python (w większości systemów) może teraz wybrać "
"najkrótszy z nich i po prostu wyświetlić ``0.1``."

msgid ""
"Note that this is in the very nature of binary floating-point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"Zauważ, że leży to w samej naturze binarnej liczby zmiennoprzecinkowej: nie "
"jest to błąd w Pythonie ani w twoim kodzie. Zobaczysz to samo we wszystkich "
"językach obsługujących arytmetykę zmiennoprzecinkową twojego sprzętu "
"(chociaż niektóre języki mogą nie *wyświetlać* różnicy domyślnie lub we "
"wszystkich trybach wyjściowych)."

msgid ""
"For more pleasant output, you may wish to use string formatting to produce a "
"limited number of significant digits::"
msgstr ""
"Aby uzyskać przyjemniejszy wynik, możesz użyć formatowania ciągu znaków w "
"celu uzyskania ograniczonej liczby cyfr znaczących::"

msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're "
"simply rounding the *display* of the true machine value."
msgstr ""
"Ważne jest, aby zdać sobie sprawę, że w rzeczywistości jest to złudzenie: po "
"prostu zaokrąglasz *wyświetlanie* prawdziwej wartości zapisanej w komputerze."

msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10, "
"summing three values of 0.1 may not yield exactly 0.3, either::"
msgstr ""
"Jedna iluzja może zrodzić kolejną. Na przykład, z powodu że 0,1 nie jest "
"dokładnie 1/10, zsumowanie trzech wartości 0,1 może nie dać dokładnie 0,3::"

msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 "
"cannot get any closer to the exact value of 3/10, then pre-rounding with :"
"func:`round` function cannot help::"
msgstr ""
"Ponadto, ponieważ 0,1 nie może zbliżyć się do dokładnej wartości 1/10, a 0,3 "
"nie może zbliżyć się do dokładnej wartości 3/10, to wstępne zaokrąglenie za "
"pomocą funkcji :func:`round` nie może pomóc::"

msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`round` function can be useful for post-rounding so that results "
"with inexact values become comparable to one another::"
msgstr ""
"Chociaż liczb nie można już bardziej przybliżyć do ich dokładnych wartości, "
"funkcja :func:`round` może być przydatna do późniejszego zaokrąglenia, tak "
"aby wyniki z niedokładnymi wartościami stały się porównywalne ze sobą::"

msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `The Perils of Floating Point "
"<https://www.lahey.com/float.htm>`_ for a more complete account of other "
"common surprises."
msgstr ""
"Binarna arytmetyka zmiennoprzecinkowa kryje w sobie wiele takich "
"niespodzianek. Problem z „0,1” został szczegółowo wyjaśniony poniżej, w "
"sekcji „Błąd reprezentacji”. Zobacz `The Perils of Floating Point <https://"
"www.lahey.com/float.htm>`_ (Niebezpieczeństwa liczb zmiennoprzecinkowych), "
"aby uzyskać pełniejszy opis innych często spotykanych niespodzianek."

msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"Jak jest tam napisane pod koniec, „nie ma łatwych odpowiedzi”. Mimo to nie "
"należy nadmiernie uważać na liczby zmiennoprzecinkowe! Błędy w operacjach "
"zmiennoprzecinkowych Pythona są dziedziczone z budowy komputera i na "
"większości maszyn są rzędu nie więcej niż 1 przez 2\\*\\*53 na operację. "
"Jest to więcej niż wystarczające dla większości zadań, ale należy pamiętać, "
"że nie jest to arytmetyka dziesiętna i że każda operacja zmiennoprzecinkowa "
"może napotkać nowy błąd zaokrąglenia."

msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"Chociaż istnieją przypadki skrajne, w większości przypadkowych zastosowań "
"arytmetyki zmiennoprzecinkowej zobaczysz oczekiwany wynik, jeśli po prostu "
"zaokrąglisz wyświetlanie końcowych wyników do oczekiwanej liczby cyfr "
"dziesiętnych. :func:`str` zwykle wystarcza, lecz dla dokładniejszej kontroli "
"możesz zobaczyć opis formatowania tekstu za pomocą metody :meth:`str.format` "
"w :ref:`formatstrings`."

msgid ""
"For use cases which require exact decimal representation, try using the :mod:"
"`decimal` module which implements decimal arithmetic suitable for accounting "
"applications and high-precision applications."
msgstr ""
"W przypadkach użycia, które wymagają dokładnej reprezentacji dziesiętnej, "
"spróbuj użyć modułu :mod:`decimal`, który implementuje arytmetykę dziesiętną "
"odpowiednią dla aplikacji księgowych i aplikacji o wysokiej precyzji."

msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module "
"which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"Inną formą wspierającą arytmetykę dokładną jest moduł :mod:`fractions` "
"realizujący arytmetykę opartą na liczbach wymiernych (aby liczby takie jak "
"1/3 mogły być reprezentowane dokładnie)."

msgid ""
"If you are a heavy user of floating point operations you should take a look "
"at the NumPy package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See <https://scipy."
"org>."
msgstr ""
"Jeśli często korzystasz z operacji zmiennoprzecinkowych, powinieneś rzucić "
"okiem na pakiet NumPy i wiele innych pakietów do operacji matematycznych i "
"statystycznych dostarczonych przez projekt SciPy. Zobacz <https://scipy.org>."

msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The :meth:`float."
"as_integer_ratio` method expresses the value of a float as a fraction::"
msgstr ""
"Python udostępnia narzędzia, które mogą pomóc w tych rzadkich przypadkach, "
"gdy naprawdę *musisz* poznać dokładną wartość liczby zmiennoprzecinkowej. "
"Metoda :meth:`float.as_integer_ratio` wyraża wartość float jako ułamek::"

msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original "
"value::"
msgstr ""
"Ponieważ stosunek jest dokładny, można go użyć do bezstratnego odtworzenia "
"oryginalnej wartości::"

msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer::"
msgstr ""
"Metoda :meth:`float.hex` wyraża liczbę zmiennoprzecinkową w systemie "
"hexadecymalnym (podstawa 16), ponownie podając dokładną wartość "
"przechowywaną przez komputer::"

msgid ""
"This precise hexadecimal representation can be used to reconstruct the float "
"value exactly::"
msgstr ""
"Ta precyzyjna reprezentacja szesnastkowa może być wykorzystana do dokładnego "
"zrekonstruowania wartości liczby zmiennoprzecinkowej::"

msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"Ponieważ ta reprezentacja jest dokładna, przydatna jest ona do niezawodnego "
"przenoszenia wartości między różnymi wersjami Pythona (niezależność od "
"platformy) i wymiany danych z innymi językami obsługującymi ten sam format "
"(takimi jak Java czy C99)."

msgid ""
"Another helpful tool is the :func:`math.fsum` function which helps mitigate "
"loss-of-precision during summation.  It tracks \"lost digits\" as values are "
"added onto a running total.  That can make a difference in overall accuracy "
"so that the errors do not accumulate to the point where they affect the "
"final total:"
msgstr ""
"Kolejnym pomocnym narzędziem jest funkcja :func:`math.fsum`, która pomaga "
"złagodzić utratę precyzji podczas sumowania. Śledzi „utracone cyfry”, gdy "
"wartości są dodawane do bieżącej sumy. Może to mieć wpływ na ogólną "
"dokładność, aby błędy nie kumulowały się do punktu, w którym wpływają na "
"ostateczny wynik:"

msgid "Representation Error"
msgstr "Błąd reprezentacji"

msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"Ta sekcja wyjaśnia szczegółowo przykład „0,1” i pokazuje, jak samodzielnie "
"przeprowadzić dokładną analizę takich przypadków. Zakładamy że masz "
"podstawową znajomość binarnej reprezentacji liczb zmiennoprzecinkowych."

msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
":dfn:`Błąd reprezentacji` odnosi się do faktu, że niektóre (właściwie "
"większość) ułamków dziesiętnych nie może być reprezentowane dokładnie jako "
"ułamki binarne (o podstawie 2). Jest to główny powód, dla którego Python "
"(lub Perl, C, C++, Java, Fortran i wiele innych) często nie wyświetla "
"dokładnie takiej liczby dziesiętnej, jakiej oczekujesz."

msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction. Almost "
"all machines today (November 2000) use IEEE-754 floating point arithmetic, "
"and almost all platforms map Python floats to IEEE-754 \"double "
"precision\".  754 doubles contain 53 bits of precision, so on input the "
"computer strives to convert 0.1 to the closest fraction it can of the form "
"*J*/2**\\ *N* where *J* is an integer containing exactly 53 bits.  "
"Rewriting ::"
msgstr ""
"Dlaczego? 1/10 nie jest dokładnie reprezentowalne jako ułamek binarny. "
"Prawie wszystkie dzisiejsze maszyny (listopad 2000) używają arytmetyki "
"zmiennoprzecinkowej IEEE-754 i prawie wszystkie platformy odwzorowują liczby "
"zmiennoprzecinkowe Pythona na „podwójną precyzję” IEEE-754. Arytmetyka "
"podwójnej precyzji typu 754 zawiera 53 bity dokładności, więc na wejściu "
"komputer stara się zamienić 0,1 na najbliższy możliwy ułamek w postaci "
"*J*/2**\\ *N*, gdzie *J* jest liczbą całkowitą zawierającą dokładnie 53 "
"bity. Zapisując ::"

msgid "as ::"
msgstr "jako ::"

msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56::"
msgstr ""
"i pamiętając, że *J* ma dokładnie 53 bity (jest ``>= 2**52`` ale ``< "
"2**53``), najlepszą wartością dla *N* jest 56::"

msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded::"
msgstr ""
"Oznacza to, że 56 jest jedyną wartością dla *N*, która pozostawia *J* "
"dokładnie 53 bity. Najlepszą możliwą wartością dla *J* jest zatem "
"zaokrąglony iloraz::"

msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up::"
msgstr ""
"Ponieważ reszta jest większa niż połowa z 10, najlepsze przybliżenie "
"uzyskuje się zaokrąglając w górę::"

msgid ""
"Therefore the best possible approximation to 1/10 in 754 double precision "
"is::"
msgstr ""
"Dlatego najlepszym możliwym przybliżeniem do 1/10 w arytmetyce podwójnej "
"precyzji typu 754 jest::"

msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr "Podzielenie licznika i mianownika przez dwa zmniejsza ułamek do::"

msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Zauważ, że ponieważ zaokrągliliśmy w górę, jest to w rzeczywistości trochę "
"więcej niż 1/10; gdybyśmy nie zaokrąglili w górę, iloraz byłby nieco "
"mniejszy niż 1/10. Ale w żadnym wypadku nie może to być *dokładnie* 1/10!"

msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best 754 double approximation it can get::"
msgstr ""
"Tak więc komputer nigdy nie „widzi” 1/10: to, co widzi, to dokładny ułamek "
"podany powyżej, najlepsze przybliżenie w standardzie podwójnej precyzji 754, "
"jakie może uzyskać::"

msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits::"
msgstr ""
"Jeśli pomnożymy ten ułamek przez 10\\*\\*55, otrzymamy wartość z "
"dokładnością do 55 cyfr dziesiętnych::"

msgid ""
"meaning that the exact number stored in the computer is equal to the decimal "
"value 0.1000000000000000055511151231257827021181583404541015625. Instead of "
"displaying the full decimal value, many languages (including older versions "
"of Python), round the result to 17 significant digits::"
msgstr ""
"co oznacza, że ​​dokładna liczba zapisana w komputerze jest równa wartości "
"dziesiętnej 0,1000000000000000055511151231257827021181583404541015625. "
"Zamiast wyświetlać pełną wartość dziesiętną, wiele języków (w tym starsze "
"wersje Pythona) zaokrągla wynik do 17 cyfr znaczących::"

msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations "
"easy::"
msgstr ""
"Moduły :mod:`fractions` oraz :mod:`decimal` ułatwiają tego typu obliczenia::"
