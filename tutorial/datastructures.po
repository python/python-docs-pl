# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Maciej Olko <maciej.olko@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-31 10:59+0000\n"
"PO-Revision-Date: 2021-06-28 01:50+0000\n"
"Last-Translator: Maciej Olko <maciej.olko@gmail.com>, 2024\n"
"Language-Team: Polish (https://app.transifex.com/python-doc/teams/5390/pl/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pl\n"
"Plural-Forms: nplurals=4; plural=(n==1 ? 0 : (n%10>=2 && n%10<=4) && "
"(n%100<12 || n%100>14) ? 1 : n!=1 && (n%10>=0 && n%10<=1) || (n%10>=5 && "
"n%10<=9) || (n%100>=12 && n%100<=14) ? 2 : 3);\n"

msgid "Data Structures"
msgstr "Struktury danych"

msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"Ten rozdział opisuje bardziej szczegółowo niektóre rzeczy, które już "
"poznaliście, oraz również wprowadza nowe elementy."

msgid "More on Lists"
msgstr "Więcej na temat list"

msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"Typ danych listy ma kilka więcej metod. To wszystkie metody obiektów listy:"

msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr "Dodaje element na końcu listy. Ekwiwalent ``a[len(a):] = [x]``."

msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to "
"``a[len(a):] = iterable``."
msgstr ""
"Rozszerza listę przez dodanie wszystkich elementów iterable'a. Ekwiwalent "
"``a[len(a):] = iterable``."

msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"Wstawia element na podaną pozycję. Pierwszy argument jest indeksem elementu, "
"przed który wstawiamy, więc ``a.insert(0, x)`` wstawia na początek listy a "
"``a.insert(len(a), x)`` odpowiada ``a.append(x)``."

msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"Usuwa pierwszy element z listy, którego wartość jest równa *x*. Rzuca :exc:"
"`ValueError`, jeśli nie ma takiego elementu."

msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list. It raises an :exc:`IndexError` if the list is empty or the index is "
"outside the list range."
msgstr ""
"Usuwa element na podanej pozycji na liście i zwraca go. Jeśli nie podano "
"indeksu, ``a.pop()`` usuwa i zwraca ostatnią pozycję na liście. Funkcja "
"rzuca :exc:`IndexError`, jeśli lista jest pusta lub indeks znajduje się poza "
"zakresem listy."

msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr "Usuwa wszystkie elementy z listy. Ekwiwalent ``del a[:]``."

msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"Zwraca indeks (liczony od zera) pierwszego elementu na liście, którego "
"wartość jest równa *x*. Rzuca :exc:`ValueError`, jeśli nie ma takiego "
"elementu."

msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"Opcjonalne argumenty *start* i *end* są interpretowane jak w notacji slice i "
"służą do ograniczenia wyszukiwania do szczególnej podsekwencji listy. "
"Zwracany indeks jest wyliczany względem początku pełnej sekwencji, nie "
"względem argumentu *start*."

msgid "Return the number of times *x* appears in the list."
msgstr "Zwraca liczbę razy, jaką *x* występuje w liście."

msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Sortuje elementy listy w miejscu (argumenty mogą służyć do dostosowania "
"sortowania, patrz :func:`sorted` po ich wyjaśnienie)."

msgid "Reverse the elements of the list in place."
msgstr "Odwraca elementy listy w miejscu."

msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr "Zwraca płytką kopię listy. Ekwiwalent ``a[:]``."

msgid "An example that uses most of the list methods::"
msgstr "Przykład, który używa większość metod listy::"

msgid ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"
msgstr ""

msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [#]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"Być może zauważyłeś(-łaś), że metody takie jak ``insert``, ``remove`` czy "
"``sort``, które tylko modyfikują listę, nie mają wypisanej wartości zwrotnej "
"– zwracają domyślne ``None``. [#]_ Jest to zasada projektowa dla wszystkich "
"mutowalnych struktur danych w Pythonie."

msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and ``None`` can't be compared to "
"other types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""
"Możesz też zauważyć, że nie wszystkie dane da się posortować lub porównać. "
"Na przykład, ``[None, 'hello', 10]`` nie sortuje się, ponieważ liczby "
"całkowite nie mogą być porównywane do ciągów znaków a ``None`` nie może być "
"porównywany do innych typów. Są również typy, które nie mają określonej "
"relacji porządku. Na przykład ``3+4j < 5+7j`` nie jest poprawnym porównaniem."

msgid "Using Lists as Stacks"
msgstr "Używanie list jako stosów"

msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`~list.append`.  To retrieve "
"an item from the top of the stack, use :meth:`~list.pop` without an explicit "
"index.  For example::"
msgstr ""
"Metody listy ułatwiają używanie listy jako stosu, gdzie ostatni element "
"dodany jest pierwszym elementem pobieranym („last-in, first-out”). Aby dodać "
"element na wierzch stosu, użyj :meth:`~list.append`. Aby pobrać element z "
"wierzchu stosu, użyj :meth:`~list.pop` bez podanego indeksu. Na przykład::"

msgid ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"
msgstr ""

msgid "Using Lists as Queues"
msgstr "Używanie list jako kolejek"

msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"Można też używać list jako kolejek, gdzie pierwszy element dodany jest "
"pierwszym elementem pobieranym („first-in, first-out”); jednakże listy nie "
"są wydajne do tego celu. Appendy i popy na końcu listy są szybkie, lecz "
"inserty i popy na początku listy są wolne (ponieważ wszystkie inne elementy "
"muszą zostać przesunięte o jeden)."

msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"Aby zaimplementować kolejkę, użyj :class:`collections.deque`, która została "
"zaprojektowana, by mieć szybkie appendy i popy na obu końcach. Na przykład::"

msgid ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"
msgstr ""

msgid "List Comprehensions"
msgstr "Wyrażenia listowe"

msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"Wyrażenia listowe są zwięzłym sposobem na tworzenie list. Powszechne "
"zastosowania to tworzenie nowych list, gdzie każdy element jest wynikiem "
"jakichś operacji zastosowanych do każdego elementu innej sekwencji lub "
"iterable'a lub do tworzenia podsekwencji tych elementów, które spełniają "
"określony warunek."

msgid "For example, assume we want to create a list of squares, like::"
msgstr "Na przykład załóżmy, że chcemy stworzyć listę kwadratów, jak tu::"

msgid ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""

msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Zwróć uwagę, że ten kod tworzy (lub nadpisuje) zmienną o nazwie ``x``, która "
"wciąż istnieje po wykonaniu pętli. Możemy obliczyć listę kwadratów bez "
"żadnych efektów ubocznych w następujący sposób::"

msgid "squares = list(map(lambda x: x**2, range(10)))"
msgstr ""

msgid "or, equivalently::"
msgstr "lub równoważnie::"

msgid "squares = [x**2 for x in range(10)]"
msgstr ""

msgid "which is more concise and readable."
msgstr "co jest bardziej zwięzłe i czytelne."

msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"Wyrażenie listowe składa się z nawiasów zawierających wyrażenie oraz "
"klauzulę :keyword:`!for`, następnie zero lub więcej klauzul :keyword:`!for` "
"lub :keyword:`!if`. Rezultatem będzie nowa lista powstała z obliczenia "
"wyrażenia w kontekście klauzul :keyword:`!for` i :keyword:`!if`, które po "
"nim następują. Na przykład to wyrażenie listowe łączy elementy dwóch list, "
"jeśli nie są równe::"

msgid ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""

msgid "and it's equivalent to::"
msgstr "i jest odpowiednikiem::"

msgid ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""

msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"Zwróć uwagę, że kolejność instrukcji :keyword:`for` i :keyword:`if` jest "
"taka sama w obu fragmentach kodu."

msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"Jeśli wyrażenie jest krotką (tak jak ``(x, y)`` w poprzednim przykładzie), "
"musi być wzięte w nawias. ::"

msgid ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # create a new list with the values doubled\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # flatten a list using a listcomp with two 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""

msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"Wyrażenia listowe mogą zawierać złożone wyrażenia i zagnieżdżone funkcje::"

msgid ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"
msgstr ""

msgid "Nested List Comprehensions"
msgstr "Zagnieżdżone wyrażenia listowe"

msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"Wyrażeniem wyjściowym w wyrażeniu listowym może być każde arbitralne "
"wyrażenie, włączając inne wyrażenie listowe."

msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"Rozważmy następujący przykład macierzy 3-na-4 zaimplementowanej jako lista "
"trzech list o długości 4::"

msgid ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"
msgstr ""

msgid "The following list comprehension will transpose rows and columns::"
msgstr "Następujące wyrażenie listowe przetransponuje wiersze i kolumny::"

msgid ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""

msgid ""
"As we saw in the previous section, the inner list comprehension is evaluated "
"in the context of the :keyword:`for` that follows it, so this example is "
"equivalent to::"
msgstr ""
"Jak widzieliśmy w poprzedniej sekcji, wewnętrzne wyrażenie listowe jest "
"ewaluowane w kontekście :keyword:`for`, które po nim następuje, więc ten "
"przykład jest równoważny temu::"

msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""

msgid "which, in turn, is the same as::"
msgstr "który z kolei jest taki sam jak::"

msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""

msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"W prawdziwym świecie powinieneś(-nnaś) preferować wbudowane funkcje w "
"złożonych instrukcjach przepływu. Funkcja :func:`zip` bardzo się przyda w "
"tym przypadku::"

msgid ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"
msgstr ""

msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"W :ref:`tut-unpacking-arguments` znajdziesz wyjaśnienie znaku gwiazdki w tej "
"linii."

msgid "The :keyword:`!del` statement"
msgstr "Instrukcja :keyword:`!del`"

msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`~list."
"pop` method which returns a value.  The :keyword:`!del` statement can also "
"be used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"Element można usunąć z listy mając jego indeks zamiast wartości: instrukcją :"
"keyword:`del`. Jest ona różna od metody :meth:`~list.pop`, która zwraca "
"wartość. Instrukcji :keyword:`!del` można też użyć do usunięcia slice'ów lub "
"wyczyszczenia całej listy (zrobiliśmy to wcześniej przypisując pustą listę "
"do slice'a). Na przykład::"

msgid ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"
msgstr ""

msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` można również użyć do usuwania całych zmiennych::"

msgid ">>> del a"
msgstr ""

msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"Odniesienie się do nazwy ``a`` odtąd jest błędem (przynajmniej dopóki nie "
"przypisana jest do niej inna wartość). Później odnajdziemy więcej zastosowań "
"dla :keyword:`del`."

msgid "Tuples and Sequences"
msgstr "Krotki i sekwencje"

msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"Widzieliśmy, że listy i ciągi znaków mają wiele wspólnych własności, takich "
"jak indeksowanie i operacje slice. Są one dwoma przykładami *sekwencyjnych* "
"typów danych (patrz :ref:`typesseq`). Jako że Python jest ewoluującym "
"językiem, mogą zostać dodane inne sekwencyjne typy danych. Jest też inny "
"standardowy sekwencyjny typ danych: *krotka*."

msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"Krotka składa się z kilku wartości rozdzielonych przecinkami, na przykład::"

msgid ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # Tuples may be nested:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # Tuples are immutable:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # but they can contain mutable objects:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"
msgstr ""

msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"Jak widzisz na wyjściu krotki zawsze są otoczone nawiasami, tak aby "
"zagnieżdżone krotki były poprawnie interpretowane; wpisać je można z lub bez "
"otaczających nawiasów, chociaż często nawiasy są i tak potrzebne (jeśli "
"krotka jest częścią większego wyrażenia). Nie da się przypisać wartości do "
"pojedynczych elementów krotki, ale da się stworzyć krotki, które zawierają "
"mutowalne obiekty, takie jak listy."

msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"Mimo że krotki mogą wydawać się podobne do list, często są używane w innych "
"sytuacjach i do innych celów. Krotki są :term:`niemutowalne <immutable>` i "
"zazwyczaj zawierają heterogeniczne sekwencje elementów, do których dostęp "
"uzyskuje się przez rozpakowywanie (patrz później w tej sekcji) lub "
"indeksowanie (lub nawet przez atrybut w przypadku :func:`namedtuples "
"<collections.namedtuple>`). Listy są :term:`mutowalne <mutable>` i ich "
"elementy są zazwyczaj homogeniczne i dostęp do nich uzyskuje się przez "
"iterowanie po liście."

msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"Specjalnym problemem jest konstrukcja krotek zawierających 0 lub 1 element: "
"składnia przewiduje na to kilka sposobów. Puste krotki można konstruować "
"pustą parą nawiasów; krotkę z jednym elementem można skonstruować "
"umieszczając przecinek za wartością (nie wystarczy otoczyć pojedynczej "
"wartości nawiasami). Brzydkie, ale działa. Na przykład::"

msgid ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"
msgstr ""

msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"Instrukcja ``t = 12345, 54321, 'hello!'`` jest przykładem *pakowania "
"krotki*: wartości ``12345``, ``54321`` i ``'hello!'`` są razem zapakowane w "
"krotkę. Możliwa jest również odwrotna operacja::"

msgid ">>> x, y, z = t"
msgstr ""

msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"Takie coś nazywane jest, odpowiednio, *rozpakowywaniem sekwencji*. Takie "
"rozpakowywanie wymaga, aby po lewej stronie znaku równości było tyle samo "
"zmiennych, ile jest elementów w sekwencji. Zauważcie, że wielokrotne "
"przypisanie jest kombinacją pakowania i rozpakowywania sekwencji."

msgid "Sets"
msgstr "Zbiory"

msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python ma również typ danych dla zbiorów. Zbiór jest nieuporządkowaną "
"kolekcją bez zduplikowanych elementów. Podstawowe użycia to sprawdzenie "
"zawierania i eliminacja duplikatów. Obiekty zbiorów wspierają też operacje "
"matematyczne jak suma, iloczyn, różnica i różnica symetryczna zbiorów."

msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"Zbiory można stworzyć używając nawiasów klamrowych lub funkcji :func:`set`. "
"Uwaga: aby stworzyć pusty zbiór, musisz użyć ``set()``, nie ``{}``; to "
"drugie tworzy pusty słownik, strukturę danych, którą omówimy w następnej "
"sekcji."

msgid "Here is a brief demonstration::"
msgstr "Poniżej krótka demonstracja::"

msgid ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # show that duplicates have been "
"removed\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # fast membership testing\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # Demonstrate set operations on unique letters from two words\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # unique letters in a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # letters in a but not in b\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # letters in a or b or both\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # letters in both a and b\n"
"{'a', 'c'}\n"
">>> a ^ b                              # letters in a or b but not both\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"
msgstr ""

msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"Podobnie do :ref:`wyrażeń listowych <tut-listcomps>`, są wspierane również "
"wyrażenia zbiorów::"

msgid ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"
msgstr ""

msgid "Dictionaries"
msgstr "Słowniki"

msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`~list.append` and :meth:`~list.extend`."
msgstr ""
"Innym przydatnym typem danych wbudowanym w Pythona jest *słownik* (patrz :"
"ref:`typesmapping`). Słowniki w innych językach czasem występują jako "
"„pamięci asocjacyjne” albo „tablice asocjacyjne”. W przeciwieństwie do "
"sekwencji, które są indeksowane zakresem liczb, słowniki są indeksowane "
"przez *klucze*, które mogą być dowolnym niemutowalnym typem; ciągi znaków i "
"liczby zawsze mogą być kluczami. Można użyć krotek, jeśli zawierają tylko "
"ciągi znaków, liczby lub krotki; jeśli krotka zawiera choć jeden mutowalny "
"obiekt, bezpośrednio lub pośrednio, nie można jej użyć jako klucza. Nie "
"możesz używać list jako kluczy, jako że listy mogą być modyfikowane „w "
"miejscu” przy użyciu przypisań do indeksu, przypisań do slice'ów lub metod "
"jak :meth:`~list.append` i :meth:`~list.extend`."

msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"Najlepiej jest myśleć o słowniku jako zbiorze par *klucz: wartość*, z "
"wymaganiem aby klucze były unikalne (w obrębie jednego słownika). Para "
"nawiasów klamrowych tworzy pusty słownik: ``{}``. Umieszczenie listy par "
"klucz:wartość rozdzielonych przecinkami dodaje początkowe pary do słownika; "
"w ten sposób również słowniki są wypisywane na wyjściu."

msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"Głównymi operacjami na słowniku są umieszczanie wartości  pod jakimś kluczem "
"oraz wyciąganie wartości dla podanego klucza. Możliwe jest również usunięcie "
"pary klucz:wartość przy użyciu ``del``. Jeśli umieścisz wartość używając "
"klucza, który już jest w użyciu, stara wartość powiązana z tym kluczem "
"zostanie zapomniana. Próba wyciągnięcia wartości przy użyciu nieistniejącego "
"klucza zakończy się błędem."

msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"Wykonanie ``list(d)`` na słowniku zwraca listę wszystkich kluczy używanych w "
"słowniku, w kolejności wstawiania (jeśli chcesz je posortować, użyj "
"``sorted(d)``). Aby sprawdzić, czy pojedynczy klucz jest w słowniku, użyj "
"słowa kluczowego :keyword:`in`."

msgid "Here is a small example using a dictionary::"
msgstr "Mały przykład użycia słownika::"

msgid ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"
msgstr ""

msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"Konstruktor :func:`dict` buduje słowniki bezpośrednio z sekwencji par klucz-"
"wartość::"

msgid ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""

msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"Dodatkowo można użyć wyrażeń słownikowych to tworzenia słowników z podanych "
"wyrażeń klucza i wartości::"

msgid ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"
msgstr ""

msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"Kiedy klucze są prostymi ciągami znaków, czasem łatwiej jest podać pary "
"używając argumentów nazwanych::"

msgid ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""

msgid "Looping Techniques"
msgstr "Techniki pętli"

msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`~dict.items` method. ::"
msgstr ""
"Podczas iterowania po słownikach, klucz i odpowiadającą mu wartość można "
"pobrać w tym samym czasie używając metody :meth:`~dict.items`. ::"

msgid ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"
msgstr ""

msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"Przy iterowaniu po sekwencji, indeks pozycyjny i odpowiadającą mu wartość "
"można pobrać w tym samym czasie używając funkcji :func:`enumerate`. ::"

msgid ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"
msgstr ""

msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"Aby przeiterować po dwóch lub więcej sekwencjach w tym samym czasie, "
"elementy mogą zostać zgrupowane funkcją :func:`zip`. ::"

msgid ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"What is your name?  It is lancelot.\n"
"What is your quest?  It is the holy grail.\n"
"What is your favorite color?  It is blue."
msgstr ""

msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"Aby przeiterować po sekwencji od końca, najpierw określ sekwencję w kierunku "
"„do przodu” a następnie wywołaj funkcję :func:`reversed`. ::"

msgid ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"
msgstr ""

msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"Aby przeiterować po sekwencji w posortowanej kolejności, użyj funkcji :func:"
"`sorted`, która zwraca nową posortowaną listę pozostawiając listę źródłową "
"niezmienioną. ::"

msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"
msgstr ""

msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of :"
"func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"Użycie :func:`set` na sekwencji eliminuje zduplikowane elementy. Użycie :"
"func:`sorted` w połączeniu z :func:`set` na sekwencji jest idiomatycznym "
"sposobem na przeiterowanie po unikalnych elementach sekwencji w posortowanej "
"kolejności. ::"

msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"
msgstr ""

msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"Czasem kusi, żeby zmienić listę podczas iterowania po niej; jednak często "
"prościej i bezpieczniej jest stworzyć nową listę. ::"

msgid ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"
msgstr ""

msgid "More on Conditions"
msgstr "Więcej na temat warunków"

msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"Warunki użyte w instrukcjach ``while`` i ``if`` mogą zawierać dowolne "
"operatory, nie tylko porównania."

msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"Operatory porównania ``in`` i ``not in`` są testami należenia, które "
"ustalają, czy wartość występuje (nie występuje) w kontenerze. Operatory "
"``is`` i ``is not`` porównują, czy dwa obiekty są rzeczywiście tym samym "
"obiektem. Wszystkie operatory porównań mają ten sam priorytet, który jest "
"niższy niż ten, który mają wszystkie operatory numeryczne."

msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"Porównania mogą być układane w łańcuchy. Na przykład ``a < b == c`` "
"sprawdza, czy ``a`` jest mniejsze od ``b`` i ponadto czy ``b`` równa się "
"``c``."

msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"Porównania można łączyć używając operatorów boolowskich ``and`` i ``or``. "
"Wynik porównania (lub jakiegokolwiek innego wyrażenia boolowskiego) można "
"zanegować używając ``not``. Operatory te mają mniejszy priorytet niż "
"operatory porównania; wśród nich ``not`` ma najwyższy priorytet a ``or`` "
"najniższy, więc ``A and not B or C`` jest ekwiwalentem ``(A and (not B)) or "
"C``. Jak zwykle można użyć nawiasów, aby wyrazić pożądaną kolejność "
"kompozycji wyrażenia."

msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"Argumenty operatorów boolowskich ``and`` i ``or`` są ewaluowane od lewej do "
"prawej. Ewaluacja kończy się w momencie ustalenia wyniku. Na przykład, jeśli "
"``A`` i ``C`` są prawdą, ale ``B`` jest fałszem, ``A and B and C`` nie "
"zewaluuje wyrażenia ``C``. Przy użyciu ogólnej wartości, nie jako boolean, "
"wartość zwracana tych operatorów to ostatnio ewaluowany argument."

msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"Da się przypisać wynik porównania lub inne wyrażenie boolowskie do zmiennej. "
"Na przykład, ::"

msgid ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"
msgstr ""

msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"Zwróć uwagę, że w Pythonie, w przeciwieństwie do C, przypisanie wewnątrz "
"wyrażeń musi być wyrażone bezpośrednio przez użycie :ref:`walrus operatora "
"<why-can-t-i-use-an-assignment-in-an-expression>` ``:=``. W ten sposób "
"unikamy powszechnej klasy problemów spotykanych w programach C: wpisywania "
"``=`` w wyrażeniu, gdy miało się intencję wpisać ``==``."

msgid "Comparing Sequences and Other Types"
msgstr "Porównywanie sekwencji i innych typów"

msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome "
"of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"Obiekty sekwencji zazwyczaj mogą być porównywane do innych obiektów, o tym "
"samym typie sekwencji. Porównanie używa porządku *leksykograficznego*: "
"pierwszy albo pierwsze dwa elementy są porównywane, i jeśli się różnią, to "
"determinuje wynik porównania; jeśli są równe, następne dwa elementy są "
"porównywane, i tak dalej, dopóki któraś z sekwencji się nie skończy. Jeśli "
"dwa elementy do porównania same są sekwencjami tego samego typu, porównanie "
"leksykograficzne odbywa się rekursywnie. Jeśli wszystkie elementy dwóch "
"sekwencji są równe, takie sekwencje są traktowane jako równe. Jeśli jedna "
"sekwencja jest początkową sub-sekwencją drugiej, ta krótsza sekwencja jest "
"mniejszą. Porządek leksykograficzny ciągów znaków używa liczby tablicy "
"Unicode do wyznaczenia porządku pojedynczych znaków. Niektóre przykłady "
"porównań pomiędzy sekwencjami takiego samego typu::"

msgid ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"
msgstr ""

msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"Zwróć uwagę, że porównywanie obiektów innych typów przy użyciu ``<`` lub "
"``>`` jest dozwolone pod warunkiem, że te obiekty mają odpowiednie metody "
"porównań. Na przykład mieszane typy numeryczne są porównywane w oparciu o "
"ich wartość numeryczną, tak że 0 równa się 0.0 i tak dalej. W innych "
"przypadkach, zamiast zwracać arbitralny porządek, interpreter zgłosi "
"wyjątek :exc:`TypeError`."

msgid "Footnotes"
msgstr "Przypisy"

msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"Inne języki mogą zwracać zmieniony obiekt, co pozwala na łańcuchowanie "
"metod, na przykład ``d->insert(\"a\")->remove(\"b\")->sort();``."
